| package |
package := Package name: 'FloatExtensions'.
package paxVersion: 0;
	basicComment: 'This package adds several methods to Float that allow code to detect the presence of infinities, denormalized values, NaNs, and the like.  Also provided are methods which allow Floats to be converted to and from integers which represents the same bit pattern.  These latter methods are useful for creating infinities, indefinites, denorms, etc, which are usually not generated by Dolphin Smalltalk.  (By default Dolphin enables all FPU exceptions except for the _EM_INEXACT (inexact result, or precision) exception rather than allowing denorms and NaNs to creep into calculations.  This behavior can be changed by using Process>>fpeMask:).

As I dug into this subject I came across an astounding amount of incorrent information regarding the IEEE-754 standard on the Web.  In fact, *every* web page I came across (with the notable exception of Intel''s site) had at least *some* of the information incorrect.  Here are a some of the errors, along with the correct information:

	1.  There are positive and negative NaNs (Not A Number)
		No.  The sign bit is not significant for NaNs except in one case, the ''indefinite'' value.  NaNs,
		however, are sign-less.  See http://developer.intel.com/design/intarch/techinfo/Pentium/fpu.htm for
		further information.

	2.  There is a single bit pattern which represents postive (or negative) underflows (and overflows).
		No.  Although the numeric underflow and overflow exceptions can be masked off there is
		no single bit pattern produced for overflow or underflow values.  The bit patterns which
		are produced in the cases of numeric over-or-underflow depend on the sign and magnitude
		of the result and the rounding mode in effect at the time the over/underflow occurs.  See
		http://developer.intel.com/design/intarch/techinfo/Pentium/fpu.htm for further information.

	3.  The ''indefinite'' value is not a NaN and should not be grouped with the NaNs.
		No.  The real indefinite value (16rFFF8000000000000) is a "quiet" NaN (QNaN).  This is
		the one case where the sign bit of a NaN is significant, but this does not mean that an
		indefinite is negative.  It''s simply a special bit pattern indicating that an invalid operation
		exception occurred when the invalid operation exception mask in the FPU was set to 1
		(indicating that invalid operation exceptions should not be generated).


Copyright (c) 2001-2004 Robert Jarvis

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
'.


package methodNames
	add: #Float -> #asQword;
	add: #Float -> #fromQword:;
	add: #Float -> #isDenormalized;
	add: #Float -> #isFloatZero;
	add: #Float -> #isIndefinite;
	add: #Float -> #isInfinity;
	add: #Float -> #isNaN;
	add: #Float -> #isNegativeDenormalized;
	add: #Float -> #isNegativeInfinity;
	add: #Float -> #isNegativeNormalized;
	add: #Float -> #isNegativeZero;
	add: #Float -> #isNormalized;
	add: #Float -> #isPositiveDenormalized;
	add: #Float -> #isPositiveInfinity;
	add: #Float -> #isPositiveNormalized;
	add: #Float -> #isPositiveZero;
	add: #Float -> #isQuietNaN;
	add: #Float -> #isSignalingNaN;
	add: 'Float class' -> #negativeInfinity;
	add: 'Float class' -> #positiveInfinity;
	yourself.

package binaryGlobalNames: (Set new
	yourself).

package globalAliases: (Set new
	yourself).

package allResourceNames: (Set new
	yourself).

package setPrerequisites: (IdentitySet new
	add: '..\..\Object Arts\Dolphin\Base\Dolphin';
	yourself).

package!

"Class Definitions"!


"Global Aliases"!


"Loose Methods"!

!Float methodsFor!

asQword
	"Answer the value of the bytes of the receiver as a quadword"

	^(ByteArray fromAddress: self yourAddress length: self size) qwordAtOffset: 0!

fromQword: aNumber
	| val aray |
	val := aNumber.
	aray := ByteArray new: self size.
	aray qwordAtOffset: 0 put: aNumber.
	aray replaceBytesOf: self from: 1 to: self size startingAt: 1	!

isDenormalized
	^self isPositiveDenormalized | self isNegativeDenormalized!

isFloatZero
	"Slightly awkward method name to avoid clash with #isZero"
	^self isPositiveZero | self isNegativeZero!

isIndefinite
	^self asQword = 16rFFF8000000000000!

isInfinity
	^self isPositiveInfinity | self isNegativeInfinity!

isNaN
	^self isSignalingNaN | self isQuietNaN!

isNegativeDenormalized
	| q |
	q := self asQword.
	^(q >= 16r8000000000000001) & (q <= 16r800FFFFFFFFFFFFF)!

isNegativeInfinity
	^self asQword = 16rFFF0000000000000!

isNegativeNormalized
	| q |
	q := self asQword.
	^(q >= 16r8010000000000000) & (q <= 16rFFEFFFFFFFFFFFFF)!

isNegativeZero
	^self asQword = 16r8000000000000000!

isNormalized
	^self isPositiveNormalized | self isNegativeNormalized!

isPositiveDenormalized
	| q |
	q := self asQword.
	^(q >= 1) & (q <= 16rFFFFFFFFFFFFF)!

isPositiveInfinity
	^self asQword = 16r7FF0000000000000!

isPositiveNormalized
	| q |
	q := self asQword.
	^(q >= 16r10000000000000) & (q <= 16r7FEFFFFFFFFFFFFF)!

isPositiveZero
	^self asQword = 0!

isQuietNaN
	| q |

	"Mask off the sign bit as it is not significant for NaN's."

	q := self asQword bitAnd: 16r7FFFFFFFFFFFFFFF.
	^((q >= 16r7FF8000000000000) & (q <= 16r7FFFFFFFFFFFFFFF)) | self isIndefinite!

isSignalingNaN
	| q |

	"Mask off the sign bit as it is not significant/meaningful for NaN's."

	q := self asQword bitAnd: 16r7FFFFFFFFFFFFFFF.
	^(q >= 16r7FF0000000000001) & (q <= 16r7FF7FFFFFFFFFFFF)! !
!Float categoriesFor: #asQword!converting!public! !
!Float categoriesFor: #fromQword:!converting!public! !
!Float categoriesFor: #isDenormalized!public!testing! !
!Float categoriesFor: #isFloatZero!public!testing! !
!Float categoriesFor: #isIndefinite!public!testing! !
!Float categoriesFor: #isInfinity!public!testing! !
!Float categoriesFor: #isNaN!public!testing! !
!Float categoriesFor: #isNegativeDenormalized!public!testing! !
!Float categoriesFor: #isNegativeInfinity!public!testing! !
!Float categoriesFor: #isNegativeNormalized!public!testing! !
!Float categoriesFor: #isNegativeZero!public!testing! !
!Float categoriesFor: #isNormalized!public!testing! !
!Float categoriesFor: #isPositiveDenormalized!public!testing! !
!Float categoriesFor: #isPositiveInfinity!public!testing! !
!Float categoriesFor: #isPositiveNormalized!public!testing! !
!Float categoriesFor: #isPositiveZero!public!testing! !
!Float categoriesFor: #isQuietNaN!public!testing! !
!Float categoriesFor: #isSignalingNaN!public!testing! !

!Float class methodsFor!

negativeInfinity
	^self new fromQword: 16rFFF0000000000000!

positiveInfinity
	^self new fromQword: 16r7FF0000000000000! !
!Float class categoriesFor: #negativeInfinity!public! !
!Float class categoriesFor: #positiveInfinity!public! !

"End of package definition"!

"Source Globals"!

"Classes"!

"Binary Globals"!

"Resources"!

